<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DORM Streaming Demo</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1100px;
            margin: 0 auto;
            padding: 20px;
        }

        h1 {
            color: #2563eb;
        }

        .card {
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-bottom: 20px;
        }

        .row {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        .col {
            flex: 1;
        }

        button {
            background-color: #2563eb;
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #1d4ed8;
        }

        button:disabled {
            background-color: #93c5fd;
            cursor: not-allowed;
        }

        input {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
            width: 100%;
            margin-bottom: 10px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .controls {
            margin-bottom: 20px;
        }

        pre {
            background-color: #f7f7f7;
            padding: 15px;
            border-radius: 4px;
            overflow: auto;
            max-height: 300px;
            font-family: 'Courier New', Courier, monospace;
        }

        .result-info {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        }

        .result-stat {
            background-color: #e0f2fe;
            padding: 10px 15px;
            border-radius: 4px;
            font-weight: 500;
        }

        .progress-bar-container {
            width: 100%;
            height: 20px;
            background-color: #ddd;
            border-radius: 10px;
            margin-bottom: 15px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background-color: #2563eb;
            width: 0%;
            transition: width 0.3s ease;
        }

        #log {
            overflow: auto;
            max-height: 200px;
        }
    </style>
</head>

<body>
    <h1>üõèÔ∏è DORM Streaming Demo</h1>

    <div class="card">
        <h2>Generate Records</h2>
        <div class="controls">
            <label for="recordCount">Number of records to generate (1-50):</label>
            <input type="number" id="recordCount" min="1" max="50" value="50">
            <button id="generateBtn">Generate Records</button>
        </div>
        <div id="generateResult"></div>
    </div>

    <div class="card">
        <h2>Stream Records</h2>
        <div class="controls">
            <label for="limitCount">Limit results (optional):</label>
            <input type="number" id="limitCount" min="1" placeholder="Leave empty for all records">
            <label for="filterName">Filter by name (optional):</label>
            <input type="text" id="filterName" placeholder="Filter pattern (e.g. 'Record 1%')">
            <button id="streamBtn">Stream Records</button>
        </div>

        <div class="progress-bar-container">
            <div id="progressBar" class="progress-bar"></div>
        </div>

        <div class="result-info">
            <div class="result-stat">Total: <span id="totalCount">0</span></div>
            <div class="result-stat">Received: <span id="receivedCount">0</span></div>
            <div class="result-stat">Time: <span id="elapsedTime">0ms</span></div>
            <div class="result-stat">DB Size: <span id="dbSize">0 KB</span></div>
        </div>

        <h3>Log</h3>
        <pre id="log"></pre>

        <h3>Results (first 10 rows)</h3>
        <pre id="results"></pre>
    </div>

    <!-- Include exec.js directly -->
    <script src="/src/exec.js"></script>

    <script>
        // DOM Elements
        const generateBtn = document.getElementById('generateBtn');
        const streamBtn = document.getElementById('streamBtn');
        const recordCount = document.getElementById('recordCount');
        const limitCount = document.getElementById('limitCount');
        const filterName = document.getElementById('filterName');
        const generateResult = document.getElementById('generateResult');
        const totalCount = document.getElementById('totalCount');
        const receivedCount = document.getElementById('receivedCount');
        const elapsedTime = document.getElementById('elapsedTime');
        const dbSize = document.getElementById('dbSize');
        const log = document.getElementById('log');
        const results = document.getElementById('results');
        const progressBar = document.getElementById('progressBar');

        // Helper function to log messages
        function logMessage(message) {
            const timestamp = new Date().toISOString().split('T')[1].slice(0, -1);
            log.textContent = `[${timestamp}] ${message}\n` + log.textContent;
        }

        // Get DB size on page load
        async function updateDbSize() {
            try {
                const response = await fetch('/api/db-size');
                const data = await response.json();
                if (data.success) {
                    const sizeInKB = Math.round(data.size / 1024 * 100) / 100;
                    dbSize.textContent = `${sizeInKB} KB`;
                }
            } catch (error) {
                console.error('Error fetching DB size:', error);
            }
        }



        // Generate records
        generateBtn.addEventListener('click', async () => {
            const count = parseInt(recordCount.value, 10);
            if (isNaN(count) || count < 1 || count > 50) {
                generateResult.textContent = 'Please enter a valid number between 1 and 50';
                return;
            }

            generateBtn.disabled = true;
            logMessage(`Generating ${count} records...`);

            try {
                const response = await fetch('/api/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ count })
                });

                const data = await response.json();
                if (data.success) {
                    generateResult.textContent = `Successfully generated ${data.count} records`;
                    logMessage(`Generated ${data.count} records successfully`);
                    updateDbSize();
                } else {
                    generateResult.textContent = `Error: ${data.error}`;
                    logMessage(`Error generating records: ${data.error}`);
                }
            } catch (error) {
                generateResult.textContent = `Error: ${error.message}`;
                logMessage(`Error: ${error.message}`);
            } finally {
                generateBtn.disabled = false;
            }
        });

        // Create a mock DO stub that uses fetch for browser use
        class BrowserDOStub {
            constructor(endpoint) {
                this.endpoint = endpoint;
            }

            fetch(request) {
                return fetch(this.endpoint, {
                    method: request.method,
                    headers: request.headers,
                    body: request.body
                });
            }
        }

        // Stream records using the exec.js library
        streamBtn.addEventListener('click', async () => {
            const limit = limitCount.value ? parseInt(limitCount.value, 10) : null;
            const filter = filterName.value;

            // Build SQL query based on filters
            let sql = 'SELECT * FROM records';
            const params = [];

            if (filter) {
                sql += ' WHERE name LIKE ?';
                params.push(filter);
            }

            if (limit && !isNaN(limit) && limit > 0) {
                sql += ' LIMIT ?';
                params.push(limit);
            }

            // Reset UI
            streamBtn.disabled = true;
            totalCount.textContent = '0';
            receivedCount.textContent = '0';
            elapsedTime.textContent = '0ms';
            progressBar.style.width = '0%';
            results.textContent = '';

            logMessage(`Starting stream query: ${sql}`);

            // Start timing
            const startTime = performance.now();
            let rowCount = 0;
            let firstRows = [];

            try {
                // Create the browser stub that points to the /db/exec endpoint
                const stub = new BrowserDOStub("/db/exec")
                // Use the exec function from exec.js to perform the query
                const cursor = await exec(stub, sql, ...params);
                console.log({ cursor })
                // Function to process results as they come in
                const processResults = async () => {
                    // Wait for initial column information
                    await new Promise(resolve => {
                        const checkColumns = () => {
                            if (cursor.columnNames && cursor.columnNames.length > 0) {
                                logMessage(`Columns received: ${cursor.columnNames.join(', ')}`);
                                resolve();
                            } else {
                                setTimeout(checkColumns, 50);
                            }
                        };
                        checkColumns();
                    });

                    // Set up iterator to process rows as they arrive
                    const processRows = async () => {
                        for (const row of cursor.raw()) {
                            rowCount++;
                            receivedCount.textContent = rowCount;

                            // Keep first 10 rows for display
                            if (firstRows.length < 10) {
                                // Convert array to object with column names
                                const rowObj = {};
                                cursor.columnNames.forEach((col, idx) => {
                                    rowObj[col] = row[idx];
                                });

                                firstRows.push(rowObj);
                                results.textContent = firstRows.map(r => JSON.stringify(r)).join('\n');
                            }

                            // Update progress if we have total info
                            if (cursor.rowsRead > 0) {
                                totalCount.textContent = cursor.rowsRead;
                                const percent = Math.min(100, Math.round((rowCount / cursor.rowsRead) * 100));
                                progressBar.style.width = `${percent}%`;
                            }

                            // Small yield to keep UI responsive
                            await new Promise(resolve => setTimeout(resolve, 0));
                        }
                    };

                    // Wait for streaming to complete
                    await Promise.all([
                        processRows(),
                        cursor.waitForStreamingComplete()
                    ]);

                    // Final update after all data is processed
                    totalCount.textContent = cursor.rowsRead;
                    progressBar.style.width = '100%';

                    // Complete timing
                    const endTime = performance.now();
                    elapsedTime.textContent = `${Math.round(endTime - startTime)}ms`;
                    logMessage(`Stream complete: ${rowCount} records in ${Math.round(endTime - startTime)}ms`);
                };

                // Start processing results
                await processResults();

                // Check for any errors
                if (cursor.error) {
                    throw new Error(cursor.error);
                }

            } catch (error) {
                logMessage(`Error: ${error.message}`);
                results.textContent = `Error: ${error.message}`;
            } finally {
                streamBtn.disabled = false;
            }
        });

        // Initialize
        updateDbSize();
        logMessage('Application initialized');
    </script>
</body>

</html>