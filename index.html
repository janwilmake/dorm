<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DORM Streaming Demo</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1100px;
            margin: 0 auto;
            padding: 20px;
        }

        h1 {
            color: #2563eb;
        }

        .card {
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-bottom: 20px;
        }

        .row {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        .col {
            flex: 1;
        }

        button {
            background-color: #2563eb;
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #1d4ed8;
        }

        button:disabled {
            background-color: #93c5fd;
            cursor: not-allowed;
        }

        input {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
            width: 100%;
            margin-bottom: 10px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .controls {
            margin-bottom: 20px;
        }

        pre {
            background-color: #f7f7f7;
            padding: 15px;
            border-radius: 4px;
            overflow: auto;
            max-height: 300px;
            font-family: 'Courier New', Courier, monospace;
        }

        .result-info {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        }

        .result-stat {
            background-color: #e0f2fe;
            padding: 10px 15px;
            border-radius: 4px;
            font-weight: 500;
        }

        .progress-bar-container {
            width: 100%;
            height: 20px;
            background-color: #ddd;
            border-radius: 10px;
            margin-bottom: 15px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background-color: #2563eb;
            width: 0%;
            transition: width 0.3s ease;
        }

        #log {
            overflow: auto;
            max-height: 200px;
        }
    </style>
</head>

<body>
    <h1>DORM Streaming Demo</h1>

    <div class="card">
        <h2>Generate Records</h2>
        <div class="controls">
            <label for="recordCount">Number of records to generate (1-1000):</label>
            <input type="number" id="recordCount" min="1" max="1000" value="100">
            <button id="generateBtn">Generate Records</button>
        </div>
        <div id="generateResult"></div>
    </div>

    <div class="card">
        <h2>Stream Records</h2>
        <div class="controls">
            <label for="limitCount">Limit results (optional):</label>
            <input type="number" id="limitCount" min="1" placeholder="Leave empty for all records">
            <label for="filterName">Filter by name (optional):</label>
            <input type="text" id="filterName" placeholder="Filter pattern (e.g. 'Record 1%')">
            <button id="streamBtn">Stream Records</button>
        </div>

        <div class="progress-bar-container">
            <div id="progressBar" class="progress-bar"></div>
        </div>

        <div class="result-info">
            <div class="result-stat">Total: <span id="totalCount">0</span></div>
            <div class="result-stat">Received: <span id="receivedCount">0</span></div>
            <div class="result-stat">Time: <span id="elapsedTime">0ms</span></div>
            <div class="result-stat">DB Size: <span id="dbSize">0 KB</span></div>
        </div>

        <h3>Log</h3>
        <pre id="log"></pre>

        <h3>Results (first 10 rows)</h3>
        <pre id="results"></pre>
    </div>

    <script>
        // DOM Elements
        const generateBtn = document.getElementById('generateBtn');
        const streamBtn = document.getElementById('streamBtn');
        const recordCount = document.getElementById('recordCount');
        const limitCount = document.getElementById('limitCount');
        const filterName = document.getElementById('filterName');
        const generateResult = document.getElementById('generateResult');
        const totalCount = document.getElementById('totalCount');
        const receivedCount = document.getElementById('receivedCount');
        const elapsedTime = document.getElementById('elapsedTime');
        const dbSize = document.getElementById('dbSize');
        const log = document.getElementById('log');
        const results = document.getElementById('results');
        const progressBar = document.getElementById('progressBar');

        // Helper function to log messages
        function logMessage(message) {
            const timestamp = new Date().toISOString().split('T')[1].slice(0, -1);
            log.textContent = `[${timestamp}] ${message}\n` + log.textContent;
        }

        // Get DB size on page load
        async function updateDbSize() {
            try {
                const response = await fetch('/api/db-size');
                const data = await response.json();
                if (data.success) {
                    const sizeInKB = Math.round(data.size / 1024 * 100) / 100;
                    dbSize.textContent = `${sizeInKB} KB`;
                }
            } catch (error) {
                console.error('Error fetching DB size:', error);
            }
        }

        // Generate records
        generateBtn.addEventListener('click', async () => {
            const count = parseInt(recordCount.value, 10);
            if (isNaN(count) || count < 1 || count > 1000) {
                generateResult.textContent = 'Please enter a valid number between 1 and 1000';
                return;
            }

            generateBtn.disabled = true;
            logMessage(`Generating ${count} records...`);

            try {
                const response = await fetch('/api/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ count })
                });

                const data = await response.json();
                if (data.success) {
                    generateResult.textContent = `Successfully generated ${data.count} records`;
                    logMessage(`Generated ${data.count} records successfully`);
                    updateDbSize();
                } else {
                    generateResult.textContent = `Error: ${data.error}`;
                    logMessage(`Error generating records: ${data.error}`);
                }
            } catch (error) {
                generateResult.textContent = `Error: ${error.message}`;
                logMessage(`Error: ${error.message}`);
            } finally {
                generateBtn.disabled = false;
            }
        });

        // Stream records
        streamBtn.addEventListener('click', async () => {
            const limit = limitCount.value ? parseInt(limitCount.value, 10) : null;
            const filter = filterName.value;

            // Build SQL query based on filters
            let sql = 'SELECT * FROM records';
            const params = [];

            if (filter) {
                sql += ' WHERE name LIKE ?';
                params.push(filter);
            }

            if (limit && !isNaN(limit) && limit > 0) {
                sql += ' LIMIT ?';
                params.push(limit);
            }

            // Reset UI
            streamBtn.disabled = true;
            totalCount.textContent = '0';
            receivedCount.textContent = '0';
            elapsedTime.textContent = '0ms';
            progressBar.style.width = '0%';
            results.textContent = '';

            logMessage(`Starting stream query: ${sql}`);

            // Start timing
            const startTime = performance.now();
            let rowCount = 0;
            let firstRows = [];

            try {
                // Create request to /db/exec endpoint
                const response = await fetch('/db/exec', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sql, params })
                });

                if (!response.ok) {
                    throw new Error(`Server returned ${response.status}: ${response.statusText}`);
                }

                // Get reader for the stream
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';

                while (true) {
                    const { done, value } = await reader.read();

                    if (done) {
                        // Process any remaining buffer content
                        if (buffer) {
                            processChunk(buffer);
                        }
                        break;
                    }

                    // Decode the chunk and add to buffer
                    buffer += decoder.decode(value, { stream: true });

                    // Process complete lines (each line is a JSON object)
                    const lines = buffer.split('\n');
                    buffer = lines.pop() || ''; // Keep the last (potentially incomplete) line

                    for (const line of lines) {
                        if (line.trim()) {
                            processLine(line);
                        }
                    }
                }

                // Complete timing
                const endTime = performance.now();
                elapsedTime.textContent = `${Math.round(endTime - startTime)}ms`;
                logMessage(`Stream complete: ${rowCount} records in ${Math.round(endTime - startTime)}ms`);

            } catch (error) {
                logMessage(`Error: ${error.message}`);
                results.textContent = `Error: ${error.message}`;
            } finally {
                streamBtn.disabled = false;
            }

            // Process a complete JSON line from the stream
            function processLine(line) {
                try {
                    const message = JSON.parse(line);

                    switch (message.type) {
                        case 'columns':
                            // Got column names
                            totalCount.textContent = 'Pending...';
                            logMessage(`Columns received: ${message.data.join(', ')}`);
                            break;

                        case 'row':
                            // Got a data row
                            rowCount++;
                            receivedCount.textContent = rowCount;

                            // Keep first 10 rows for display
                            if (firstRows.length < 10) {
                                firstRows.push(message.data);
                                // Update the results display
                                results.textContent = firstRows.map(row => JSON.stringify(row)).join('\n');
                            }

                            break;

                        case 'meta':
                            // Got metadata (end of results)
                            totalCount.textContent = message.data.rows_read;
                            progressBar.style.width = '100%';
                            break;

                        case 'error':
                            logMessage(`Stream error: ${message.error}`);
                            break;
                    }

                    // Update progress if we have total count
                    if (totalCount.textContent !== 'Pending...' && totalCount.textContent !== '0') {
                        const total = parseInt(totalCount.textContent, 10);
                        const percent = Math.min(100, Math.round((rowCount / total) * 100));
                        progressBar.style.width = `${percent}%`;
                    }

                } catch (error) {
                    logMessage(`Error processing stream data: ${error.message}`);
                }
            }

            // Process a chunk of text that might contain multiple lines
            function processChunk(chunk) {
                const lines = chunk.split('\n');
                for (const line of lines) {
                    if (line.trim()) {
                        processLine(line);
                    }
                }
            }
        });

        // Initialize
        updateDbSize();
        logMessage('Application initialized');
    </script>
</body>

</html>